import * as fs from 'fs';
import { DomainMap, DomainBoundary, VibeFlowConfig, BoundaryConfig } from '../types/config.js';
import { ConfigLoader } from '../utils/config-loader.js';
import { VibeFlowPaths } from '../utils/file-paths.js';

export interface ArchitecturalPlan {
  overview: string;
  modules: ModuleDesign[];
  migration_strategy: MigrationStrategy;
  implementation_guide: ImplementationGuide;
  quality_gates: QualityGate[];
}

export interface ModuleDesign {
  name: string;
  description: string;
  current_state: ModuleState;
  target_state: ModuleState;
  refactoring_actions: RefactoringAction[];
  dependencies: ModuleDependency[];
  interfaces: InterfaceDefinition[];
}

export interface ModuleState {
  files: string[];
  lines_of_code: number;
  test_coverage: number;
  cyclomatic_complexity: number;
  coupling_score: number;
  cohesion_score: number;
}

export interface RefactoringAction {
  type: 'extract_interface' | 'move_file' | 'create_value_object' | 'split_function' | 'introduce_event';
  description: string;
  files_affected: string[];
  priority: 'high' | 'medium' | 'low';
  effort_estimate: string;
}

export interface ModuleDependency {
  module: string;
  type: 'interface' | 'event' | 'shared_data';
  description: string;
}

export interface InterfaceDefinition {
  name: string;
  purpose: string;
  methods: string[];
  go_definition?: string;
  typescript_definition?: string;
  python_definition?: string;
}

export interface MigrationStrategy {
  phases: MigrationPhase[];
  rollback_plan: string;
  validation_steps: string[];
}

export interface MigrationPhase {
  name: string;
  duration: string;
  modules: string[];
  actions: RefactoringAction[];
  success_criteria: string[];
  risks: Risk[];
}

export interface Risk {
  description: string;
  probability: 'low' | 'medium' | 'high';
  impact: 'low' | 'medium' | 'high';
  mitigation: string;
}

export interface ImplementationGuide {
  directory_structure: DirectoryStructure;
  naming_conventions: NamingConvention[];
  code_patterns: CodePattern[];
  testing_strategy: TestingStrategy;
}

export interface DirectoryStructure {
  [module: string]: string[];
}

export interface NamingConvention {
  type: string;
  pattern: string;
  example: string;
}

export interface CodePattern {
  name: string;
  description: string;
  example: string;
  language: string;
}

export interface TestingStrategy {
  unit_tests: string;
  integration_tests: string;
  e2e_tests: string;
  coverage_target: number;
}

export interface QualityGate {
  name: string;
  description: string;
  metric: string;
  threshold: number;
  current_value: number;
}

export interface ArchitectAnalysisResult {
  plan: ArchitecturalPlan;
  outputPath: string;
}

export class ArchitectAgent {
  private config: VibeFlowConfig;
  private boundaryConfig: BoundaryConfig | null;
  private paths: VibeFlowPaths;

  constructor(projectRoot: string, configPath?: string, boundaryConfigPath?: string) {
    this.config = ConfigLoader.loadVibeFlowConfig(configPath);
    this.boundaryConfig = ConfigLoader.loadBoundaryConfig(boundaryConfigPath);
    this.paths = new VibeFlowPaths(projectRoot);
  }

  async generateArchitecturalPlan(domainMapPath: string): Promise<ArchitectAnalysisResult> {
    console.log('üèóÔ∏è  „É¢„Ç∏„É•„É©„Éº„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÇíË®≠Ë®à‰∏≠...');
    
    // 1. „Éâ„É°„Ç§„É≥„Éû„ÉÉ„ÉóË™≠„ÅøËæº„Åø
    const domainMap = this.loadDomainMap(domainMapPath);
    
    // 2. „É¢„Ç∏„É•„Éº„É´Ë®≠Ë®à
    const modules = this.designModules(domainMap.boundaries);
    
    // 3. ÁßªË°åÊà¶Áï•Á≠ñÂÆö
    const migrationStrategy = this.createMigrationStrategy(modules);
    
    // 4. ÂÆüË£Ö„Ç¨„Ç§„Éâ‰ΩúÊàê
    const implementationGuide = this.createImplementationGuide(modules);
    
    // 5. ÂìÅË≥™„Ç≤„Éº„ÉàÂÆöÁæ©
    const qualityGates = this.defineQualityGates(domainMap);
    
    // 6. „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ë®àÁîªÁµ±Âêà
    const plan: ArchitecturalPlan = {
      overview: this.generateOverview(domainMap, modules),
      modules,
      migration_strategy: migrationStrategy,
      implementation_guide: implementationGuide,
      quality_gates: qualityGates,
    };

    // 7. Ë®àÁîªÂá∫Âäõ
    const outputPath = this.paths.planPath;
    const planMarkdown = this.generatePlanMarkdown(plan);
    fs.writeFileSync(outputPath, planMarkdown);
    
    console.log(`‚úÖ „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ë®àÁîª„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü: ${this.paths.getRelativePath(outputPath)}`);
    
    return { plan, outputPath };
  }

  private loadDomainMap(filePath: string): DomainMap {
    if (!fs.existsSync(filePath)) {
      throw new Error(`Domain map file not found: ${filePath}`);
    }
    
    const content = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(content) as DomainMap;
  }

  private designModules(boundaries: DomainBoundary[]): ModuleDesign[] {
    return boundaries.map(boundary => this.designModule(boundary));
  }

  private designModule(boundary: DomainBoundary): ModuleDesign {
    const currentState: ModuleState = {
      files: boundary.files,
      lines_of_code: boundary.files.length * 100, // Rough estimate
      test_coverage: this.config.refactoring.quality_gates.test_coverage.current,
      cyclomatic_complexity: 5, // Default estimate
      coupling_score: boundary.coupling_score ?? boundary.metrics?.coupling ?? 0,
      cohesion_score: boundary.cohesion_score ?? boundary.metrics?.cohesion ?? 0,
    };

    const targetState: ModuleState = {
      ...currentState,
      test_coverage: this.config.refactoring.quality_gates.test_coverage.minimum,
      coupling_score: Math.max(0, (boundary.coupling_score ?? boundary.metrics?.coupling ?? 0) - 0.3),
      cohesion_score: Math.min(1, (boundary.cohesion_score ?? boundary.metrics?.cohesion ?? 0) + 0.2),
    };

    const refactoringActions = this.generateRefactoringActions(boundary, currentState, targetState);
    const dependencies = this.extractModuleDependencies(boundary);
    const interfaces = this.defineModuleInterfaces(boundary);

    return {
      name: boundary.name,
      description: boundary.description,
      current_state: currentState,
      target_state: targetState,
      refactoring_actions: refactoringActions,
      dependencies,
      interfaces,
    };
  }

  private generateRefactoringActions(
    boundary: DomainBoundary,
    currentState: ModuleState,
    targetState: ModuleState
  ): RefactoringAction[] {
    const actions: RefactoringAction[] = [];

    // High coupling ‚Üí Interface extraction
    if (currentState.coupling_score > 0.5) {
      actions.push({
        type: 'extract_interface',
        description: `${boundary.name}„É¢„Ç∏„É•„Éº„É´„ÅÆÂ§ñÈÉ®‰æùÂ≠ò„ÇíÂâäÊ∏õ„Åô„Çã„Åü„ÇÅ„ÅÆ„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπÊäΩÂá∫`,
        files_affected: (boundary.dependencies?.internal ?? []).slice(0, 3),
        priority: 'high',
        effort_estimate: '1-2ÈÄ±Èñì',
      });
    }

    // Value objects for primitive obsession
    const valueObjects = this.config.refactoring.value_objects.priority_high;
    if (valueObjects.length > 0) {
      actions.push({
        type: 'create_value_object',
        description: `„Éó„É™„Éü„ÉÜ„Ç£„ÉñÂûã„ÅÆË™§Áî®„ÇíÈò≤„Åê„Åü„ÇÅ„ÅÆÂÄ§„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà‰ΩúÊàê: ${valueObjects.join(', ')}`,
        files_affected: boundary.files.filter(f => f.includes('model') || f.includes('type')),
        priority: 'high',
        effort_estimate: '3-5Êó•',
      });
    }

    // Low test coverage ‚Üí Test enhancement
    if (currentState.test_coverage < targetState.test_coverage) {
      actions.push({
        type: 'split_function',
        description: `„ÉÜ„Çπ„Éà„Ç´„Éê„É¨„ÉÉ„Ç∏Âêë‰∏ä„ÅÆ„Åü„ÇÅ„ÅÆÈñ¢Êï∞ÂàÜÂâ≤„Å®„ÉÜ„Çπ„ÉàËøΩÂä†`,
        files_affected: boundary.files,
        priority: 'medium',
        effort_estimate: '1-2ÈÄ±Èñì',
      });
    }

    // Circular dependencies ‚Üí Event-driven architecture
    if (boundary.circular_dependencies && boundary.circular_dependencies.length > 0) {
      actions.push({
        type: 'introduce_event',
        description: `Âæ™Áí∞‰æùÂ≠òËß£Ê∂à„ÅÆ„Åü„ÇÅ„ÅÆ„Ç§„Éô„É≥„ÉàÈßÜÂãï„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Â∞éÂÖ•`,
        files_affected: boundary.circular_dependencies,
        priority: 'high',
        effort_estimate: '2-3ÈÄ±Èñì',
      });
    }

    return actions;
  }

  private extractModuleDependencies(boundary: DomainBoundary): ModuleDependency[] {
    const dependencies: ModuleDependency[] = [];
    
    if (this.boundaryConfig) {
      const moduleConfig = this.boundaryConfig.modules[boundary.name];
      if (moduleConfig) {
        moduleConfig.depends_on?.forEach(dep => {
          dependencies.push({
            module: dep.split('.')[0], // Extract module name from interface path
            type: 'interface',
            description: `${dep}„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„Å´‰æùÂ≠ò`,
          });
        });
      }
    }

    return dependencies;
  }

  private defineModuleInterfaces(boundary: DomainBoundary): InterfaceDefinition[] {
    const interfaces: InterfaceDefinition[] = [];
    
    if (this.boundaryConfig) {
      const moduleConfig = this.boundaryConfig.modules[boundary.name];
      if (moduleConfig?.provides_interfaces) {
        moduleConfig.provides_interfaces.forEach(interfaceName => {
          interfaces.push({
            name: interfaceName,
            purpose: `${boundary.name}„É¢„Ç∏„É•„Éº„É´„ÅÆ‰∏ªË¶Å„Çµ„Éº„Éì„Çπ„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ`,
            methods: ['Get', 'Create', 'Update', 'Delete'], // Default CRUD
            go_definition: this.generateGoInterface(interfaceName),
          });
        });
      }
    }

    return interfaces;
  }

  private generateGoInterface(interfaceName: string): string {
    const serviceName = interfaceName.replace('.', '');
    return `type ${serviceName} interface {
    Get(ctx context.Context, id string) (*Entity, error)
    Create(ctx context.Context, entity *Entity) error
    Update(ctx context.Context, entity *Entity) error
    Delete(ctx context.Context, id string) error
}`;
  }

  private createMigrationStrategy(modules: ModuleDesign[]): MigrationStrategy {
    const configPhases = this.config.migration.phases;
    const phases: MigrationPhase[] = [];

    for (const [phaseKey, phaseConfig] of Object.entries(configPhases)) {
      const phaseModules = modules.filter(m => phaseConfig.modules.includes(m.name));
      const phaseActions = phaseModules.flatMap(m => m.refactoring_actions);

      phases.push({
        name: phaseConfig.name,
        duration: phaseConfig.duration,
        modules: phaseConfig.modules,
        actions: phaseActions,
        success_criteria: [
          '„Åô„Åπ„Å¶„ÅÆ„ÉÜ„Çπ„Éà„ÅåÈÄö„Çã',
          '„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Åå10%‰ª•ÂÜÖ„ÅÆÂä£Âåñ',
          '„É°„Éà„É™„ÇØ„Çπ„ÅåÁõÆÊ®ôÂÄ§„ÇíÈÅîÊàê',
        ],
        risks: [
          {
            description: '„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥‰∏≠„ÅÆ„Éá„Éº„Çø‰∏çÊï¥Âêà',
            probability: 'medium',
            impact: 'high',
            mitigation: '„É≠„Éº„É´„Éê„ÉÉ„ÇØË®àÁîª„ÅÆÊ∫ñÂÇô„Å®„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó‰ΩúÊàê',
          },
        ],
      });
    }

    return {
      phases,
      rollback_plan: 'Git„Çí‰ΩøÁî®„Åó„ÅüÊÆµÈöéÁöÑ„É≠„Éº„É´„Éê„ÉÉ„ÇØ„ÄÇÂêÑ„Éï„Çß„Éº„Ç∫ÂÆå‰∫ÜÂæå„Å´„Çø„Ç∞‰ΩúÊàê„ÄÇ',
      validation_steps: [
        '„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„ÉàÂÆüË°å',
        '„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà',
        '„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Çπ„Ç≠„É£„É≥',
        '„Ç≥„Éº„Éâ„É°„Éà„É™„ÇØ„ÇπÊ§úË®º',
      ],
    };
  }

  private createImplementationGuide(modules: ModuleDesign[]): ImplementationGuide {
    const directoryStructure: DirectoryStructure = {};
    
    modules.forEach(module => {
      directoryStructure[module.name] = [
        `internal/${module.name}/`,
        `internal/${module.name}/domain/`,
        `internal/${module.name}/usecase/`,
        `internal/${module.name}/repository/`,
        `internal/${module.name}/handler/`,
      ];
    });

    return {
      directory_structure: directoryStructure,
      naming_conventions: [
        {
          type: 'Interface',
          pattern: 'I{ServiceName}',
          example: 'ICustomerService',
        },
        {
          type: 'Repository',
          pattern: '{Entity}Repository',
          example: 'CustomerRepository',
        },
      ],
      code_patterns: [
        {
          name: 'Dependency Injection',
          description: 'Google Wire„Çí‰ΩøÁî®„Åó„Åü‰æùÂ≠òÊÄßÊ≥®ÂÖ•',
          example: '//+build wireinject',
          language: 'go',
        },
      ],
      testing_strategy: {
        unit_tests: '„É¢„Ç∏„É•„Éº„É´ÂÜÖ„ÅÆÈñ¢Êï∞„Éª„É°„ÇΩ„ÉÉ„Éâ„É¨„Éô„É´',
        integration_tests: '„É¢„Ç∏„É•„Éº„É´Èñì„ÅÆ„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÉÜ„Çπ„Éà',
        e2e_tests: 'API„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„É¨„Éô„É´',
        coverage_target: this.config.refactoring.quality_gates.test_coverage.minimum,
      },
    };
  }

  private defineQualityGates(domainMap: DomainMap): QualityGate[] {
    return [
      {
        name: '„ÉÜ„Çπ„Éà„Ç´„Éê„É¨„ÉÉ„Ç∏',
        description: 'ÊúÄ‰Ωé„ÉÜ„Çπ„Éà„Ç´„Éê„É¨„ÉÉ„Ç∏Ë¶Å‰ª∂',
        metric: 'coverage_percentage',
        threshold: this.config.refactoring.quality_gates.test_coverage.minimum,
        current_value: this.config.refactoring.quality_gates.test_coverage.current,
      },
      {
        name: '„É¢„Ç∏„É•„É©„É™„ÉÜ„Ç£„Çπ„Ç≥„Ç¢',
        description: 'ÂÖ®‰ΩìÁöÑ„Å™„É¢„Ç∏„É•„Éº„É´ÊÄßË©ï‰æ°',
        metric: 'modularity_score',
        threshold: 0.7,
        current_value: domainMap.metrics.modularity_score,
      },
      {
        name: 'Âæ™Áí∞‰æùÂ≠ò',
        description: 'Âæ™Áí∞‰æùÂ≠ò„ÅÆÊï∞',
        metric: 'circular_dependencies_count',
        threshold: 0,
        current_value: domainMap.boundaries.reduce((sum, b) => sum + (b.circular_dependencies?.length || 0), 0),
      },
    ];
  }

  private generateOverview(domainMap: DomainMap, modules: ModuleDesign[]): string {
    return `# ${domainMap.project} „É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞Ë®àÁîª

## ÁèæÁä∂ÂàÜÊûê
- Á∑è„Éï„Ç°„Ç§„É´Êï∞: ${domainMap.total_files}
- Ë≠òÂà•„Åï„Çå„Åü„É¢„Ç∏„É•„Éº„É´: ${modules.length}ÂÄã
- ÂÖ®‰ΩìÁöÑÂáùÈõÜÂ∫¶: ${domainMap.metrics.overall_cohesion}
- ÂÖ®‰ΩìÁöÑÁµêÂêàÂ∫¶: ${domainMap.metrics.overall_coupling}
- „É¢„Ç∏„É•„É©„É™„ÉÜ„Ç£„Çπ„Ç≥„Ç¢: ${domainMap.metrics.modularity_score}

## ÁõÆÊ®ô„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£
${this.config.refactoring.target_architecture.pattern}„Éë„Çø„Éº„É≥„Å´„Çà„Çã${this.config.refactoring.target_architecture.module_structure}„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„Å∏„ÅÆÁßªË°å„ÄÇ

## ‰∏ªË¶Å„Å™ÊîπÂñÑÁÇπ
- „ÉÜ„Çπ„Éà„Ç´„Éê„É¨„ÉÉ„Ç∏„Çí${this.config.refactoring.quality_gates.test_coverage.current}%„Åã„Çâ${this.config.refactoring.quality_gates.test_coverage.minimum}%„Å´Âêë‰∏ä
- „É¢„Ç∏„É•„Éº„É´Èñì„ÅÆÁµêÂêàÂ∫¶ÂâäÊ∏õ
- ÂÄ§„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´„Çà„ÇãÂûãÂÆâÂÖ®ÊÄßÂêë‰∏ä
- „Ç§„Éô„É≥„ÉàÈßÜÂãï„Å´„Çà„ÇãÂæ™Áí∞‰æùÂ≠òËß£Ê∂à`;
  }

  private generatePlanMarkdown(plan: ArchitecturalPlan): string {
    let markdown = `# „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ë®àÁîªÊõ∏

${plan.overview}

## „É¢„Ç∏„É•„Éº„É´Ë®≠Ë®à

`;

    plan.modules.forEach(module => {
      markdown += `### ${module.name}

**Ë™¨Êòé**: ${module.description}

**ÁèæÁä∂**:
- „Éï„Ç°„Ç§„É´Êï∞: ${module.current_state.files.length}
- ÁµêÂêàÂ∫¶: ${module.current_state.coupling_score}
- ÂáùÈõÜÂ∫¶: ${module.current_state.cohesion_score}

**ÁõÆÊ®ô**:
- ÁµêÂêàÂ∫¶: ${module.target_state.coupling_score}
- ÂáùÈõÜÂ∫¶: ${module.target_state.cohesion_score}

**„É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞„Ç¢„ÇØ„Ç∑„Éß„É≥**:
${module.refactoring_actions.map(action => `- ${action.description} (${action.priority})`).join('\n')}

`;
    });

    markdown += `## ÁßªË°åÊà¶Áï•

`;

    plan.migration_strategy.phases.forEach((phase, index) => {
      markdown += `### „Éï„Çß„Éº„Ç∫${index + 1}: ${phase.name}

- ÊúüÈñì: ${phase.duration}
- ÂØæË±°„É¢„Ç∏„É•„Éº„É´: ${phase.modules.join(', ')}
- „Ç¢„ÇØ„Ç∑„Éß„É≥Êï∞: ${phase.actions.length}

`;
    });

    markdown += `## ÂìÅË≥™„Ç≤„Éº„Éà

`;

    plan.quality_gates.forEach(gate => {
      markdown += `- **${gate.name}**: ${gate.current_value} ‚Üí ${gate.threshold} (${gate.description})
`;
    });

    return markdown;
  }
}